<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/zoey.github.io/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-02T11:44:22.350Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/02/hello-world/"/>
    <id>http://yoursite.com/2020/04/02/hello-world/</id>
    <published>2020-04-02T11:44:22.350Z</published>
    <updated>2020-04-02T11:44:22.350Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://yoursite.com/2020/04/01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/04/01/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-01T08:12:30.000Z</published>
    <updated>2020-04-02T11:44:22.351Z</updated>
    
    <content type="html"><![CDATA[<h4 id="标记清除方式"><a href="#标记清除方式" class="headerlink" title="标记清除方式"></a>标记清除方式</h4><p>当变量进入执行环境时，就标记这个变量为<em>进入环境</em>状态。当变量离开环境时，则将其标记为<em>离开环境</em>。</p><p>垃圾收集器运行的时候会给<strong>存储在内存中</strong>的所有变量加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上的标记的变量被视为准备删除的变量，原因是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;标记清除方式&quot;&gt;&lt;a href=&quot;#标记清除方式&quot; class=&quot;headerlink&quot; title=&quot;标记清除方式&quot;&gt;&lt;/a&gt;标记清除方式&lt;/h4&gt;&lt;p&gt;当变量进入执行环境时，就标记这个变量为&lt;em&gt;进入环境&lt;/em&gt;状态。当变量离开环境时，则将其标记为&lt;em&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>运行时的页面构建过程</title>
    <link href="http://yoursite.com/2020/04/01/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/01/%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/</id>
    <published>2020-04-01T07:51:20.000Z</published>
    <updated>2020-04-02T11:44:22.352Z</updated>
    
    <content type="html"><![CDATA[<p>当用户在浏览器地址栏输入一串链接会发生什么？<br>从用户角度来说，浏览器构建了发送服务器的请求，该服务器处理请求并形成了一个由HTML、CSS、JS代码所组成的响应。当浏览器接收响应时，<strong>浏览器开始构建页面和事件处理</strong>。</p><h4 id="构建页面阶段"><a href="#构建页面阶段" class="headerlink" title="构建页面阶段"></a>构建页面阶段</h4><ol><li>解析HTML代码并构建文档对象模型（DOM）；</li><li>执行JS代码；<blockquote><p>步骤一会在浏览器处理HTML几点过程中执行；步骤二会在HTML解析到特殊节点（script）时执行。页面构建阶段中，这两个步骤会交替执行。每当解析到脚本元素时浏览器会停止从HTML构建DOM并开始执行JS代码；</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当用户在浏览器地址栏输入一串链接会发生什么？&lt;br&gt;从用户角度来说，浏览器构建了发送服务器的请求，该服务器处理请求并形成了一个由HTML、CSS、JS代码所组成的响应。当浏览器接收响应时，&lt;strong&gt;浏览器开始构建页面和事件处理&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>事件循环</title>
    <link href="http://yoursite.com/2020/04/01/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2020/04/01/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2020-04-01T03:29:10.000Z</published>
    <updated>2020-04-02T11:44:22.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>创建主文档对象，解析HTML，执行全局JS代码以及事件（页面加载、输入、网络事件和定时器事件）。宏任务代表一个个离散的独立工作单元。允许完任务后，浏览器可以继续其他调度，如重新渲染页面的UI或执行垃圾回收。</p><h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>微任务包括promise回调函数，DOM变化等。<br>微任务需要尽可能快的通过异步方式执行，同时不能产生全新的微任务。</p><h4 id="事件循环两个基本原则："><a href="#事件循环两个基本原则：" class="headerlink" title="事件循环两个基本原则："></a>事件循环两个基本原则：</h4><p>一次处理一个任务；<br>一个任务开始后直到运行完成，不会被其他任务中断；</p><ol><li>为什么添加任务到任务队列必须在事件循环外？<blockquote><p>若添加任务到任务队列的过程是事件循环的一部分，那么当JS代码执行时发生的事件都将被忽略。</p></blockquote></li><li>为什么不能保证定时器的回调？<blockquote><p>因为定时器会被添加进宏任务，那么当该任务前有其他任务时，该任务只能等待其他任务执行后才能执行该任务。</p></blockquote></li><li>为什么每一次事件循环的迭代不应超过16ms？<blockquote><p>因为渲染是在事件循环结束时执行，每个迭代如果超过16ms，那么浏览器达不到60帧的渲染次数，就会显得卡顿。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;宏任务与微任务&quot;&gt;&lt;a href=&quot;#宏任务与微任务&quot; class=&quot;headerlink&quot; title=&quot;宏任务与微任务&quot;&gt;&lt;/a&gt;宏任务与微任务&lt;/h3&gt;&lt;h4 id=&quot;宏任务&quot;&gt;&lt;a href=&quot;#宏任务&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>node开发日志功能</title>
    <link href="http://yoursite.com/2019/07/11/node%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2019/07/11/node%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/</id>
    <published>2019-07-11T03:31:46.000Z</published>
    <updated>2019-07-11T03:33:13.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日志需要的文件"><a href="#日志需要的文件" class="headerlink" title="日志需要的文件"></a>日志需要的文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log  <span class="comment">// 存放日志的文件夹</span></span><br><span class="line">&gt;&gt; access.log  <span class="comment">// 日志记录文件</span></span><br><span class="line">utils <span class="comment">// 工具文件夹</span></span><br><span class="line">&gt;&gt; log.js   <span class="comment">// 日志主要功能代码</span></span><br><span class="line">app.js</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><h3 id="不使用第三方日志模块方式"><a href="#不使用第三方日志模块方式" class="headerlink" title="不使用第三方日志模块方式"></a>不使用第三方日志模块方式</h3><ol><li><p>在utils/log.js文件中定义功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取文件Strema流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWriteStrema</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取文件路径</span></span><br><span class="line">    <span class="keyword">const</span> fullFileName = path.join(__dirname, <span class="string">'../log'</span>, filename)</span><br><span class="line">    <span class="comment">// 根据路径获取文件Strema流</span></span><br><span class="line">    <span class="keyword">const</span> writeStrema = fs.createWriteStrema(fullFileName, &#123;</span><br><span class="line">        flags: <span class="string">'a'</span>  <span class="comment">// 使用append方式向文件添加内容</span></span><br><span class="line">    &#125;)</span><br><span class="line">    retrun writeStrema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> accessWriteStrema = createWriteStrema(<span class="string">'access.log'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入日志</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeLog</span>(<span class="params">writeStrema, log</span>) </span>&#123;</span><br><span class="line">    writeStrema.write(log + <span class="string">'\n'</span>)  <span class="comment">// 写入到文件中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">access</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">    writeLog(accessWriteStrema, log)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    access</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在app.js中使用刚才写的日志功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; access &#125; = <span class="built_in">require</span>(<span class="string">'./utils/log'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件中写上这个中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义Log格式</span></span><br><span class="line">    <span class="keyword">const</span> log = <span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> -- <span class="subst">$&#123;ctx.url&#125;</span> -- <span class="subst">$&#123;ctx.headers[<span class="string">'user-agent'</span>]&#125;</span> -- <span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span></span><br><span class="line">    <span class="comment">// 调用写入文件方法</span></span><br><span class="line">    access(log)</span><br><span class="line">    <span class="comment">// 跳到下一个中间件</span></span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用morgan模块方式"><a href="#使用morgan模块方式" class="headerlink" title="使用morgan模块方式"></a>使用morgan模块方式</h3><ol><li><p>下载morgan模块<br> <code>npm i koa-morgan</code></p></li><li><p>app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 引入模块</span></span><br><span class="line"><span class="keyword">const</span> morgan = <span class="built_in">require</span>(<span class="string">'koa-morgan'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取记录日志的文件</span></span><br><span class="line"><span class="keyword">const</span> writeStream =fs.createWriteStream(path.resolve(__dirname, <span class="string">'./log'</span>, <span class="string">'access.log'</span>), &#123;</span><br><span class="line">    flags: <span class="string">'a'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3. 注册中间件</span></span><br><span class="line"><span class="comment">// combined 代表使用较全的格式写到文件中，这个参数可以参照官方文档选择自己需要的格式  https://github.com/expressjs/morgan</span></span><br><span class="line"><span class="comment">// :remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"</span></span><br><span class="line">app.use(mogran(<span class="string">'combined'</span>, &#123;</span><br><span class="line">    stream: writeStream <span class="comment">// 写入到文件中</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>这样就可以了，在每次访问的时候就会在日志中写入一条记录，如果在开发时不需要写入到文件中，可以使用环境变量来区分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ENV = process.env.NODE_ENV</span><br><span class="line"><span class="comment">// 如果不是正式环境就只在控制台输出 dev 格式的日志， 否则就写入 combined 格式的日志到文件中</span></span><br><span class="line"><span class="keyword">if</span> (ENV !== <span class="string">'production'</span> ) &#123;</span><br><span class="line">    app.use(morgan(<span class="string">'dev'</span>))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    app.use(mogran(<span class="string">'combined'</span>, &#123;</span><br><span class="line">        stream: writeStream <span class="comment">// 写入到文件中</span></span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;日志需要的文件&quot;&gt;&lt;a href=&quot;#日志需要的文件&quot; class=&quot;headerlink&quot; title=&quot;日志需要的文件&quot;&gt;&lt;/a&gt;日志需要的文件&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue响应原理</title>
    <link href="http://yoursite.com/2019/07/06/Vue%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/06/Vue%E5%93%8D%E5%BA%94%E5%8E%9F%E7%90%86/</id>
    <published>2019-07-06T15:32:29.000Z</published>
    <updated>2019-07-06T16:28:52.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Copy自"><a href="#Copy自" class="headerlink" title="Copy自"></a>Copy自</h3><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>Vue会遍历data选项中的所有属性，并使用<code>Object.defineProperty</code>把这些属性全部转化为<code>getter/setter</code>。<br><code>Object.defineProperty</code>是ES5中一个<strong>无法优雅降级</strong>的特性，这也是Vue不支持IE8及更低版本浏览器的原因。</p><p>这些<code>getter/setter</code>对用户来说是不可见的，但是它们让Vue能够追踪依赖，在属性被访问和修改时通过<code>getter/setter</code>来通知变更。</p><p>每个组件实例都对应一个<strong>watcher</strong>实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的setter触发时，会通知watcher，从而使它关联的组件重新渲染。</p><h3 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h3><p>受现代JavaScript的限制，Vue<strong>无法检测到对象属性的添加或删除</strong>。<br>Vue会在<strong>初始化实例时</strong>对属性执行<code>getter/setter</code>转化，所以属性必须一开始就得在<code>data</code>对象上存在才能让Vue用<code>Object.defineProperty</code>将它转化为响应式的。列如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span v-for&#x3D;&quot;(item, index) in obj&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;addObj&quot;&gt;添加属性&lt;&#x2F;button&gt; &#x2F;&#x2F; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            a:1 &#x2F;&#x2F; 响应式属性</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    addObj() &#123;</span><br><span class="line">        this.obj.b &#x3D; 2 &#x2F;&#x2F; 非响应式属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>上面的代码希望调用addObj方法向<code>this.obj</code>添加属性并且视图能够更新。失败！需要向响应式对象添加属性应该用Vue.set()方法才能将添加的属性变为响应式的。<br>对于已经创建的实例，Vue不允许动态添加根级别的响应式属性。但是，Vue提供了<code>Vue.set(obj, propertyName, value)</code>方法向嵌套对象添加响应式属性。列如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$set(this.obj, &#39;b&#39;, 2)</span><br></pre></td></tr></table></figure><p>需要为已有对象赋值多个新属性时应该用原对象与要混合进去的对象的新属性一起创建一个新对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.obj &#x3D; Object.assign(&#123;&#125;, this.obj, &#123;c: 3, d: 4&#125;)</span><br></pre></td></tr></table></figure><h3 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h3><p>Vue在更新DOM时是<strong>异步</strong>执行的。只要侦听到数据的变化，Vue将开启一个队列，并缓冲 在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作非常重要。然后，在下一个事件循环tick中，Vue刷新队列并执行实际工作。Vue在内部对异步队列尝试使用原生的<code>Promise.then</code>、<code>MutationObserver</code>和<code>setTimeOut</code>，如果执行环境不支持，则会采用<code>setTimeOut(fn, 0)</code>代替。<br>为了在数据变化之后等待Vue完成更新DOM，可以在数据变化后立即使用<code>Vue.nextTick(callback)</code>。这样回调函数将在DOM更新完后被调用。<br><code>nextTick()</code>返回一个<code>Promise</code>对象，所以可以使用<code>async/await</code>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function () &#123;</span><br><span class="line">    &lt;!-- DOM未更新 --&gt;</span><br><span class="line">    await this.$nextTick()</span><br><span class="line">    &lt;!-- DOM已更新 --&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Copy自&quot;&gt;&lt;a href=&quot;#Copy自&quot; class=&quot;headerlink&quot; title=&quot;Copy自&quot;&gt;&lt;/a&gt;Copy自&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/reactivity.html&quot; ta
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vuex基础使用</title>
    <link href="http://yoursite.com/2019/07/06/Vuex%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/06/Vuex%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2019-07-06T09:37:46.000Z</published>
    <updated>2019-07-07T02:36:11.177Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Copy自<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex官方文档</a></p></blockquote><p>Vuex是一个专门为Vue程序开发的<em>状态管理模式</em>。采用集中式存储来管理应用的所有组件的状态。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><h4 id="获取State的方式："><a href="#获取State的方式：" class="headerlink" title="获取State的方式："></a>获取State的方式：</h4><ol><li>通过根实例中注册的store选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state.count</span><br></pre></td></tr></table></figure></li><li>mapState 辅助函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &#39;vuex&#39;</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState()  &#x2F;&#x2F; mapState函数返回的是一个对象。</span><br><span class="line">    or</span><br><span class="line">    ...mapState([&#39;aount&#39;])  &#x2F;&#x2F; 可以给mapState传一个数组，数组的项是你要取的值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p><em>就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖发生了改变时才会被重新计算。</em></p><h4 id="定义方法："><a href="#定义方法：" class="headerlink" title="定义方法："></a>定义方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        todos: [</span><br><span class="line">            &#123;id:1, done: true&#125;,</span><br><span class="line">            &#123;id: 2, done: false&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        &#x2F;&#x2F; Getter 接受state作为其第一个参数</span><br><span class="line">        doneTodos(state) &#123;</span><br><span class="line">            return state.todos.filter(todo &#x3D;&gt; todo.done)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; Getter 也可以接受其他getter 作为其第二个参数</span><br><span class="line">        doneTodosCount(state, getters) &#123;</span><br><span class="line">            return getters.doneTodos.length &#x2F;&#x2F; 这里会获取到上面那个定义的getter方法(doneTodos)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 通过让getter返回一个函数，来实现给getter传参。在对store里的数组进行查询时非常有用。</span><br><span class="line">        getTodoById(state) &#123;</span><br><span class="line">            return (id) &#x3D;&gt; state.todos.find(todo &#x3D;&gt; todo.id &#x3D;&#x3D;&#x3D; id) &#x2F;&#x2F; 这里会通过参数id，从todos列表中返回Id相同的数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="获取Getter的方式："><a href="#获取Getter的方式：" class="headerlink" title="获取Getter的方式："></a>获取Getter的方式：</h4><ol><li>通过属性访问<br><code>this.$store.getters.doneTodos</code><blockquote><p>getter在通过属性访问时是作为Vue的响应式系统的一部分缓存其中的。</p></blockquote></li><li>通过方法访问（传参方式）<br><code>this.$store.getters.getTodoById(2)</code><blockquote><p>getter在通过方法访问时，每次都会去进行调用，而 <em>不会缓存结果</em>。</p></blockquote></li><li>mapGetters 辅助函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapGetters&#125; from &#39;vuex;</span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([&#39;doneTodos&#39;]) &#x2F;&#x2F; 使用对象展开运算符将getter混入computed中</span><br><span class="line">    &#x2F;&#x2F; 如果想将一个getter属性另取一个名字，使用对象形式：</span><br><span class="line">    ...mapGetters(&#123;</span><br><span class="line">        doneTodosCount: &#39;doneTodos&#39; &#x2F;&#x2F; 把this.doneTodosCount映射为this.$store.getters.doneTodos</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改store中的状态的<em>唯一方法</em>是提交mutation。</p><h4 id="定义方法：-1"><a href="#定义方法：-1" class="headerlink" title="定义方法："></a>定义方法：</h4><p>可以给mutation定义很多方法，这些方法就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数。<br>可以向mutation方法传入额外的参数，大多数情况下参数应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;...&#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment(state, payload) &#123;</span><br><span class="line">            state.count +&#x3D; payload.mount  &#x2F;&#x2F; 直接修改state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p>可以在组件中使用 <code>this.$sotre.commit(&#39;xxx&#39;)</code> 提交mutation，或者使用<code>mapMutations</code>辅助函数将组件中的methods映射为<code>store.commit</code>调用。</p><ol><li>普通方法<br><code>this.$store.commit(&#39;increment&#39;, { amount: 10 })</code></li><li>对象风格的提交方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#123;</span><br><span class="line">    type: &#39;increment&#39;,  &#x2F;&#x2F; 直接使用包含type属性的对象，其他属性为参数。</span><br><span class="line">    amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>mapMutations 辅助函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapMutations&#125; from &#39;vuex&#39;]</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">        &#39;increment&#39;,  &#x2F;&#x2F; 将 this.increment() 映射为 this.$store.commit(&#39;increment&#39;)</span><br><span class="line">        &#39;incrementBy&#39;  &#x2F;&#x2F; 将 this.incrementBy() 映射为 this.$store.commit(&#39;incrementBy&#39;)</span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">        add: &#39;increment&#39;  &#x2F;&#x2F;将 this.add 映射为 this.$store.commit(&#39;increment&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4>既然Vuex的store中的状态是响应式的，那么当我们变更状态时，监视状态的Vue组件也会自动更新。<br>这也意味着Vuex中的mutation也需要与使用Vue一样遵守一些注意事项：</li><li>最好提前在你的store中初始化好所需属性；</li><li>当需要在对象上添加新属性时，应该：<ul><li>使用Vue.set(obj, ‘newProp’, 123)</li><li>用新对象替换老对象：state.obj = {…state.obj, newProp: 123}</li></ul></li><li>mutation必须是同步函数。</li></ol><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action与mutation，不同在于：</p><ul><li>action提交的是mutaion，而不是直接变更状态</li><li>action可以包含任意异步操作<h4 id="定义方法：-2"><a href="#定义方法：-2" class="headerlink" title="定义方法："></a>定义方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment(state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        &#x2F;&#x2F; action的方法接受一个与store实例具有相同方法和属性的context对象，因此可以调用&#96;context.commit&#96;提交一个mutation。</span><br><span class="line">        increment(context) &#123;</span><br><span class="line">            context.commit(&#39;increment&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        or</span><br><span class="line">        &#x2F;&#x2F; 实践中，会使用解构来简化代码</span><br><span class="line">        increment(&#123;commit&#125;) &#123;</span><br><span class="line">            commit(&#39;increment&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用方式：-1"><a href="#使用方式：-1" class="headerlink" title="使用方式："></a>使用方式：</h4></li></ul><ol><li>action通过store.dispatch方法触发：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&#39;increment&#39;)</span><br></pre></td></tr></table></figure></li><li>传递参数方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch(&#39;increment&#39;, &#123;</span><br><span class="line">    amount: 1</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 以对象形式</span><br><span class="line">this.$store.dispatch(&#123;</span><br><span class="line">    type: &#39;increment&#39;,</span><br><span class="line">    amount: 10</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>mapActions 辅助函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapActions&#125; from &#39;vuex&#39;</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([&#39;increment&#39;]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">        add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.dispatch(&#39;increment&#39;)&#96;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="项目中使用："><a href="#项目中使用：" class="headerlink" title="项目中使用："></a>项目中使用：</h3><p><a href="https://github.com/zoey-git/vuex-module" target="_blank" rel="noopener">Vuex在项目中简单模块拆分</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Copy自&lt;a href=&quot;https://vuex.vuejs.org/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vuex官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vuex是一个专门为Vue程序开发
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue计算属性内幕</title>
    <link href="http://yoursite.com/2019/07/06/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%86%85%E5%B9%95/"/>
    <id>http://yoursite.com/2019/07/06/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%86%85%E5%B9%95/</id>
    <published>2019-07-06T08:51:12.000Z</published>
    <updated>2019-07-06T15:25:00.155Z</updated>
    
    <content type="html"><![CDATA[<p>先从案例开始。现在有一个input框用来输入数值，另有一个span标签会把货币指加上￥符号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;money&quot; &#x2F;&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;RMB&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            money: 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        RMB() &#123;</span><br><span class="line">            return &#39;￥&#39; + this.money</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这里的RMB就是一个计算属性，依赖于数据this.money，伴随后者的变化而变化。</p><h3 id="响应式属性的概念"><a href="#响应式属性的概念" class="headerlink" title="响应式属性的概念"></a>响应式属性的概念</h3><p>通过Object.defineProperty，可以创建一个带有getter和setter方法的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var bank &#x3D; &#123;moneyNornal: 1&#125;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(bank, &#39;money&#39;, &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        console.log(&#39;get money&#39;)</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&quot;money: &quot;, bank.money, +&quot;,&quot;+, bank.moneyNornal) &#x2F;&#x2F; money：1 , 1</span><br></pre></td></tr></table></figure><p>尽管使用起来一样，但实际上每次访问money属性会首先经过getter函数。vue会把所有定义在data中所返回的属性做一次definProperty处理，所以每次访问属性，vue就能监听到。</p><p>计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时才会重新求值。这就意味着只要<code>money</code>没有发生改变，多次访问<code>RMB</code>计算属性会立即返回之前的计算结果，而不必再次执行计算函数。</p><p>这也意味着下面的计算属性不会更新，因为Date.mow()不是响应式依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    now() &#123;</span><br><span class="line">        return Date.now();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么需要缓存？"><a href="#为什么需要缓存？" class="headerlink" title="为什么需要缓存？"></a>为什么需要缓存？</h4><p>假设有一个性能开销比较大的计算属性getMoney，它需要遍历一个巨大的数组并做计算。然后我们可能有其他的计算属性依赖于getMoney。如果没有缓存，我们将不可避免的多次执行A的getter！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    &#x2F;&#x2F; 在第一次执行getMoney后这个值将会被缓存，之后再获取this.getMoney时将直接取缓存，而不会执行getMoney()</span><br><span class="line">    getMoney () &#123;</span><br><span class="line">        ...巨大开销</span><br><span class="line">        console.log(&#39;执行了moneyAdd&#39;); &#x2F;&#x2F;只会打印一次</span><br><span class="line">        return this.money * 10</span><br><span class="line">    &#125;,</span><br><span class="line">    RMB() &#123;</span><br><span class="line">        console.log(&#39;执行了RMB&#39;);</span><br><span class="line">        return &#39;￥&#39; + this.getMoney</span><br><span class="line">    &#125;,</span><br><span class="line">    USD() &#123;</span><br><span class="line">        console.log(&#39;执行了USA&#39;);</span><br><span class="line">        return &#39;$&#39; + this.getMoney</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果不希望有缓存，请用方法来替代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mounted: &#123;</span><br><span class="line">    &#x2F;&#x2F; 不可避免的将多次执行getMoney()</span><br><span class="line">    getMoney () &#123;</span><br><span class="line">        ...巨大开销</span><br><span class="line">        console.log(&#39;执行了moneyAdd&#39;);</span><br><span class="line">        return this.money * 10</span><br><span class="line">    &#125;,</span><br><span class="line">    RMB() &#123;</span><br><span class="line">        console.log(&#39;执行了RMB&#39;);</span><br><span class="line">        return &#39;￥&#39; + this.getMoney()</span><br><span class="line">    &#125;,</span><br><span class="line">    USD() &#123;</span><br><span class="line">        console.log(&#39;执行了USA&#39;);</span><br><span class="line">        return &#39;$&#39; + this.getMoney()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先从案例开始。现在有一个input框用来输入数值，另有一个span标签会把货币指加上￥符号。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue-Router 路由钩子函数</title>
    <link href="http://yoursite.com/2019/07/06/%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/06/%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</id>
    <published>2019-07-06T06:28:09.000Z</published>
    <updated>2019-07-06T08:49:31.986Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>路由钩子主要用来拦截导航，在钩子里可以跳转到指定的页面或取消跳转。</p></blockquote><ul><li>路由参数或者查询的改变不会触发导航守卫！。 *可以通过watch观察$route对象来应对这些变化，或用beforeRouteUpdate的组件内守卫。<h3 id="1-全局前置守卫"><a href="#1-全局前置守卫" class="headerlink" title="1. 全局前置守卫"></a>1. 全局前置守卫</h3><h4 id="1-1-beforeEach"><a href="#1-1-beforeEach" class="headerlink" title="1.1 beforeEach"></a>1.1 beforeEach</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>当一个导航触发时，全局前置守卫按照创建的顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于* 等待中 *。</li></ul><p>每个守卫方法接收三个参数：</p><ul><li><p>to：到哪去（正要进入的路由）；</p></li><li><p>from: 从哪来（正要离开的路由）；</p></li><li><p>next: 如果是next()就完成跳转到to指示的路由；如果参数为false则取消此次导航；如果参数是地址或路由对象则调到指定的地址或对象。</p></li><li><p>确保一定要调用next 方法，否则钩子就不会被resolve。 *</p></li></ul><h3 id="2-独享路由钩子"><a href="#2-独享路由钩子" class="headerlink" title="2. 独享路由钩子"></a>2. 独享路由钩子</h3><h4 id="2-1-beforeEnter"><a href="#2-1-beforeEnter" class="headerlink" title="2.1 beforeEnter"></a>2.1 beforeEnter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#39;&#x2F;foo&#39;,</span><br><span class="line">            component: Foo,</span><br><span class="line">            beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-组件路由钩子"><a href="#3-组件路由钩子" class="headerlink" title="3. 组件路由钩子"></a>3. 组件路由钩子</h3><h4 id="3-1-beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave"><a href="#3-1-beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave" class="headerlink" title="3.1 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave"></a>3.1 beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在渲染该组件的对应路由被确认前调用，不能获取组件示例this，因为当守卫执行前，组件的实例还没被创建。</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当路由发生改变，但是该组件被复用时调用。也就是路由参数或者查询改变时。</span><br><span class="line">    &#x2F;&#x2F; 举例：对于一个动态参数的路径&#x2F;foo&#x2F;:id，当从 &#x2F;foo&#x2F;1 跳转到 &#x2F;foo&#x2F;2 时被调用。由于会渲染同一个组件，因此组件实例会被复用。所以这个钩子会在这个情况下被调用。</span><br><span class="line">    &#x2F;&#x2F; 可以访问组件this</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">    &#x2F;&#x2F; 离开该组件的对应路由时调用。</span><br><span class="line">    &#x2F;&#x2F; 可以访问组件this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>beforeRouteEnter不能访问this，但是可以通过传给next一个回调函数来访问组件实例，在导航被确认的时候会执行回调。并且把组件实例作为回调方法的参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">    next(vm &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过vm访问组件实例</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>beforeRouteLeave通常用來禁止用戶在还未保存修改前突然离开。该导航可以通过next(false)来取消跳转。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;路由钩子主要用来拦截导航，在钩子里可以跳转到指定的页面或取消跳转。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;路由参数或者查询的改变不会触发导航守卫！。 *可以通过watch观察$route对象来应对这些变化，或用beforeRoute
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
